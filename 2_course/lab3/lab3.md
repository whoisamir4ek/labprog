# Отчет по лабораторной работе 3
## Тема: Рекурсивные структуры данных. Бинарные деревья. Модульное тестирование.

---

### Задача: Построение бинарного дерева

#### Постановка задачи

Разработать программу на языке Python, которая будет строить бинарное дерево (дерево, в каждом узле которого может быть только два потомка). Отображение результата в виде словаря. Реализовать рекурсивный вариант функции `gen_bin_tree`.

Дерево должно обладать следующими свойствами:
- В корне дерева находится число, заданное пользователем
- Высота дерева задается пользователем  
- Левый потомок вычисляется как `root * 2`
- Правый потомок вычисляется как `root + 3`

#### Математическая модель

Рекурсивное определение бинарного дерева:

```
T(h, r) = {
    None, если h ≤ 0
    {value: r}, если h = 1  
    {
        value: r,
        left: T(h-1, r×2),
        right: T(h-1, r+3)
    }, если h > 1
}
```

где:
- h - высота дерева
- r - значение корневого узла

#### Список идентификаторов

| Имя переменной | Тип данных | Описание                        |
|----------------|------------|---------------------------------|
| `height`       | int        | Высота дерева                   |
| `root`         | int        | Значение корневого узла         |
| `tree`         | dict       | Текущий узел дерева             |
| `left`         | dict       | Левое поддерево                 |
| `right`        | dict       | Правое поддерево                |

#### Код программы

```python
def gen_bin_tree(height=5, root=1):
    """
    Рекурсивно строит бинарное дерево в виде словаря.
    
    Параметры:
    height (int): Высота дерева. Определяет количество уровней в дереве.
                 По умолчанию: 5
    root (int): Значение корневого узла дерева.
               По умолчанию: 1
    
    Возвращает:
    dict или None: Словарь, представляющий бинарное дерево, где:
                   - 'value': значение текущего узла
                   - 'left': левое поддерево (рекурсивный вызов)
                   - 'right': правое поддерево (рекурсивный вызов)
                   None если height <= 0
    """
    
    # БАЗОВЫЙ СЛУЧАЙ РЕКУРСИИ
    # Если высота дерева меньше или равна 0, возвращаем None
    # Это условие остановки рекурсии - достигли конца ветки
    if height <= 0:
        return None
    
    # СОЗДАНИЕ ТЕКУЩЕГО УЗЛА
    # Создаем словарь для текущего узла дерева
    # Ключ 'value' содержит значение текущего узла (root)
    tree = {"value": root}
    
    # РЕКУРСИВНЫЙ СЛУЧАЙ
    # Если высота больше 1, значит нужно строить дальнейшие уровни дерева
    if height > 1:
        # ЛЕВОЕ ПОДДЕРЕВО
        # Рекурсивный вызов для левого потомка:
        # - height - 1: уменьшаем высоту на 1 (переходим на уровень ниже)
        # - root * 2: значение левого потомка = текущее значение * 2
        tree["left"] = gen_bin_tree(height - 1, root * 2)
        
        # ПРАВОЕ ПОДДЕРЕВО
        # Рекурсивный вызов для правого потомка:
        # - height - 1: уменьшаем высоту на 1 (переходим на уровень ниже)
        # - root + 3: значение правого потомка = текущее значение + 3
        tree["right"] = gen_bin_tree(height - 1, root + 3)
    
    # ВОЗВРАТ РЕЗУЛЬТАТА
    # Возвращаем построенный узел дерева
    return tree
```

#### Результат работы программы

Для параметров `height=3, root=1` программа возвращает:

```python
{
    'value': 1,
    'left': {
        'value': 2,
        'left': {'value': 4},
        'right': {'value': 5}
    },
    'right': {
        'value': 4,
        'left': {'value': 8},
        'right': {'value': 7}
    }
}
```

---

### Задача: Модульное тестирование бинарного дерева

#### Постановка задачи

Написать модульные тесты с помощью `unittest` для проверки корректности работы функции `gen_bin_tree`. Тесты должны проверять:
- Корректность построения дерева для заданных параметров
- Правильность вычисления значений узлов
- Структуру дерева на разных уровнях

#### Математическая модель

Проверка соответствия фактического результата работы функции ожидаемым значениям:

```
Фактический_результат = gen_bin_tree(h, r)
Ожидаемый_результат = T(h, r)
Условие_корректности: Фактический_результат ≡ Ожидаемый_результат
```

#### Список идентификаторов

| Имя переменной | Тип данных | Описание                        |
|----------------|------------|---------------------------------|
| `result`       | dict       | Результат работы функции        |
| `expected`     | dict       | Ожидаемая структура дерева      |

#### Код программы

```python
import unittest

class TestMyBinTree(unittest.TestCase):
    
    def test_my_parameters(self):
        """Тест для моих параметров: root=1, height=5"""
        result = gen_bin_tree(height=5, root=1)
        
        # Проверяем корень
        self.assertEqual(result["value"], 1)
        
        # Проверяем второй уровень
        self.assertEqual(result["left"]["value"], 2)   # 1 * 2
        self.assertEqual(result["right"]["value"], 4)  # 1 + 3
        
        # Проверяем третий уровень
        self.assertEqual(result["left"]["left"]["value"], 4)   # 2 * 2
        self.assertEqual(result["left"]["right"]["value"], 5)  # 2 + 3
        self.assertEqual(result["right"]["left"]["value"], 8)  # 4 * 2
        self.assertEqual(result["right"]["right"]["value"], 7) # 4 + 3
        
        # Проверяем четвертый уровень (левая ветка)
        self.assertEqual(result["left"]["left"]["left"]["value"], 8)   # 4 * 2
        self.assertEqual(result["left"]["left"]["right"]["value"], 7)  # 4 + 3
        self.assertEqual(result["left"]["right"]["left"]["value"], 10) # 5 * 2
        self.assertEqual(result["left"]["right"]["right"]["value"], 8) # 5 + 3
        
        # Проверяем четвертый уровень (правая ветка)
        self.assertEqual(result["right"]["left"]["left"]["value"], 16)  # 8 * 2
        self.assertEqual(result["right"]["left"]["right"]["value"], 11) # 8 + 3
        self.assertEqual(result["right"]["right"]["left"]["value"], 14) # 7 * 2
        self.assertEqual(result["right"]["right"]["right"]["value"], 10) # 7 + 3

if __name__ == "__main__":
    unittest.main()
```

#### Результат работы тестов

```
.
----------------------------------------------------------------------
Ran 1 test in 0.001s

OK
```

Все тесты проходят успешно, что подтверждает корректность реализации функции построения бинарного дерева.

---

### Выводы

1. **Рекурсивный подход** успешно применен для построения бинарного дерева с заданными правилами вычисления потомков
2. **Структура данных** в виде словаря хорошо подходит для представления бинарного дерева в Python
3. **Модульное тестирование** с использованием `unittest` позволяет убедиться в корректности работы программы
4. **Алгоритм** корректно обрабатывает базовый случай (высота ≤ 0) и рекурсивно строит дерево до заданной глубины

Программа удовлетворяет всем требованиям поставленной задачи и корректно работает для заданных параметров.

---

### Информация о студенте:

*Аглиуллин Амир, 1 курс, ИВТ-1(2).*