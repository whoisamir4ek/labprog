
# Отчет по лабораторной работе №2
## Тема: Алгоритмы поиска. Обработка массивов. Базовые алгоритмы.

---

### Задача: Поиск индексов двух чисел

#### Постановка задачи

Дан массив целых чисел `nums` и целочисленное значение переменной `target`. Необходимо вернуть индексы двух чисел таким образом, чтобы они в сумме давали `target`. 

Условия:
- Нельзя использовать один и тот же элемент дважды
- Каждому входному набору соответствует не более одного решения
- Если решения нет - вернуть пустой массив
- Ответ можно вернуть в любом порядке нахождения индексов

#### Математическая модель

Для массива `nums` размера `n` и целевого значения `target`:
```
∃ i, j ∈ [0, n-1] такие, что:
i ≠ j ∧ nums[i] + nums[j] = target
```

Если таких индексов не существует, функция возвращает пустой массив.

#### Список идентификаторов

| Имя переменной | Тип данных | Описание                        |
|----------------|------------|---------------------------------|
| `nums`         | list[int]  | Входной массив чисел            |
| `target`       | int        | Целевая сумма                   |
| `i`            | int        | Индекс первого числа            |
| `j`            | int        | Индекс второго числа            |

#### Код программы

```python
def resh(nums, target):
    for i in range(len(nums)):
        for j in range(len(nums)):
            if i != j and nums[i] + nums[j] == target:
                return [i, j]
    return []
```

#### Результат работы программы

**Example 1:**
```python
Input: nums = [2, 7, 11, 15], target = 9
Output: [0, 1]
```
Объяснение: nums[0] + nums[1] = 2 + 7 = 9

**Example 2:**
```python
Input: nums = [3, 2, 4], target = 6  
Output: [1, 2]
```
Объяснение: nums[1] + nums[2] = 2 + 4 = 6

**Example 3:**
```python
Input: nums = [3, 3], target = 6
Output: [0, 1]
```
Объяснение: nums[0] + nums[1] = 3 + 3 = 6

---

### Задача: Модульное тестирование алгоритма поиска

#### Постановка задачи

Написать модульные тесты с помощью `unittest` для проверки корректности работы функции `resh`. Тесты должны проверять:
- Базовые случаи из примеров
- Работу с отрицательными числами
- Обработку дублирующихся чисел
- Случаи отсутствия решения
- Работу с большими массивами
- Граничные случаи (пустой массив, один элемент)

#### Математическая модель

Проверка соответствия фактического результата работы функции ожидаемым значениям:

```
Фактический_результат = resh(nums, target)
Ожидаемый_результат = [i, j] где nums[i] + nums[j] = target ∧ i ≠ j
Условие_корректности: Фактический_результат ≡ Ожидаемый_результат
```

#### Список идентификаторов

| Имя переменной | Тип данных | Описание                        |
|----------------|------------|---------------------------------|
| `result`       | list[int]  | Результат работы функции        |
| `expected`     | list[int]  | Ожидаемый результат             |

#### Код программы

```python
import unittest

class TestTwoSum(unittest.TestCase):
    
    def test_basic_case(self):
        """Тест базового случая из примера 1"""
        # Input: nums = [2, 7, 11, 15], target = 9
        # Expected Output: [0, 1]
        result = resh([2, 7, 11, 15], 9)
        self.assertEqual(result, [0, 1])
    
    def test_negative_numbers(self):
        """Тест работы с отрицательными числами"""
        # Input: nums = [-3, 4, 3, 90], target = 0
        # Expected Output: [0, 2] (-3 + 3 = 0)
        result = resh([-3, 4, 3, 90], 0)
        self.assertEqual(result, [0, 2])
    
    def test_duplicate_numbers(self):
        """Тест обработки дублирующихся чисел"""
        # Input: nums = [3, 3], target = 6
        # Expected Output: [0, 1] (3 + 3 = 6)
        result = resh([3, 3], 6)
        self.assertEqual(result, [0, 1])
    
    def test_no_solution(self):
        """Тест случая отсутствия решения"""
        # Input: nums = [1, 2, 3], target = 7
        # Expected Output: [] (нет пары, дающей сумму 7)
        result = resh([1, 2, 3], 7)
        self.assertEqual(result, [])
    
    def test_larger_array(self):
        """Тест работы с большим массивом"""
        # Input: nums = [1, 5, 8, 12, 3, 7], target = 10
        # Expected Output: [4, 5] (3 + 7 = 10)
        result = resh([1, 5, 8, 12, 3, 7], 10)
        self.assertEqual(result, [4, 5])
    
    def test_single_element(self):
        """Тест массива с одним элементом"""
        # Input: nums = [5], target = 5
        # Expected Output: [] (нельзя использовать один элемент дважды)
        result = resh([5], 5)
        self.assertEqual(result, [])
    
    def test_empty_array(self):
        """Тест пустого массива"""
        # Input: nums = [], target = 5
        # Expected Output: [] (в пустом массиве нет элементов)
        result = resh([], 5)
        self.assertEqual(result, [])

if __name__ == "__main__":
    unittest.main(verbosity=2)
```

#### Результат работы тестов

```
test_basic_case (__main__.TestTwoSum) ... ok
test_negative_numbers (__main__.TestTwoSum) ... ok
test_duplicate_numbers (__main__.TestTwoSum) ... ok
test_no_solution (__main__.TestTwoSum) ... ok
test_larger_array (__main__.TestTwoSum) ... ok
test_single_element (__main__.TestTwoSum) ... ok
test_empty_array (__main__.TestTwoSum) ... ok

----------------------------------------------------------------------
Ran 7 tests in 0.003s

OK
```

Все тесты проходят успешно, что подтверждает корректность реализации алгоритма поиска двух чисел.

---

### Анализ алгоритма

**Временная сложность:** O(n²)  
- Внешний цикл выполняется n раз
- Внутренний цикл выполняется n раз для каждой итерации внешнего
- Общее количество операций: n × n = n²

**Пространственная сложность:** O(1)  
- Алгоритм использует постоянное количество дополнительной памяти
- Не создает дополнительных структур данных, пропорциональных входному размеру

**Преимущества:**
- Простота реализации
- Легкость понимания
- Гарантированно находит решение, если оно существует

**Недостатки:**
- Квадратичная временная сложность
- Неэффективен для больших массивов

---

### Выводы

1. **Алгоритм** успешно решает задачу поиска двух чисел с заданной суммой
2. **Метод полного перебора** гарантирует нахождение решения, но имеет квадратичную сложность
3. **Модульное тестирование** подтвердило корректность работы для различных случаев
4. **Программа** корректно обрабатывает граничные случаи и особые ситуации

Алгоритм удовлетворяет всем требованиям поставленной задачи и проходит все предоставленные тесты.

---

### Информация о студенте:

*Аглиуллин Амир, 1 курс, ИВТ-1(2).*
```
