def gen_bin_tree(height=5, root=1):
    # Базовый случай: если высота дерева равна или меньше 0, возвращаем пустое дерево
    if height <= 0:
        return {}
    
    # Инициализация словаря для хранения структуры дерева
    tree = {}
    # Очередь для обхода узлов в ширину (BFS), каждый элемент - кортеж (значение_узла, уровень)
    level = []
    level.append((root, 1))  # Добавляем корневой узел с уровнем 1

    # Основной цикл: обрабатываем узлы пока очередь не пуста
    while level:
        # Извлекаем первый элемент из очереди (FIFO)
        value, level_height = level.pop(0)

        # Создаем запись для текущего узла в словаре дерева
        tree[value] = {}

        # Проверяем, не достигли ли максимальной высоты дерева
        if level_height < height:
            # Вычисляем значения для левого и правого потомков
            left_leaf = value * 2      # Левый потомок = текущее значение × 2
            right_leaf = value + 3     # Правый потомок = текущее значение + 3

            # Добавляем потомков в структуру текущего узла
            tree[value]['left'] = left_leaf
            tree[value]['right'] = right_leaf

            # Добавляем потомков в очередь для дальнейшей обработки
            level.append((left_leaf, level_height + 1))
            level.append((right_leaf, level_height + 1))
        else:
            # Если достигли максимальной высоты - устанавливаем потомков как None (листья)
            tree[value]['left'] = None
            tree[value]['right'] = None
            
    # Возвращаем готовое бинарное дерево в виде словаря
    return tree