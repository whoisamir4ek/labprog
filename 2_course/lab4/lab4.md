# Отчет по лабораторной работе 4
## Тема: Нерекурсивные структуры данных. Бинарные деревья. Модульное тестирование.

---

### Задача: Нерекурсивное построение бинарного дерева

#### Постановка задачи

Разработать программу на языке Python, которая будет строить бинарное дерево нерекурсивным методом. Исследовать различные структуры данных для хранения дерева, включая базовые словари и структуры из модуля collections. Отображение результата в виде словаря.

Дерево должно обладать следующими свойствами:
- В корне дерева находится число, заданное пользователем
- Высота дерева задается пользователем  
- Левый потомок вычисляется как `root * 2`
- Правый потомок вычисляется как `root + 3`

#### Математическая модель

Итеративное определение бинарного дерева с использованием очереди:

```
T(h, r) = {
    {}, если h ≤ 0
    {r: {left: None, right: None}}, если h = 1
    {
        r: {left: r×2, right: r+3},
        r×2: {left: None, right: None},
        r+3: {left: None, right: None}
    }, если h = 2
    ...
}
```

где:
- h - высота дерева
- r - значение корневого узла
- Обработка узлов осуществляется по принципу FIFO (очередь)

#### Список идентификаторов

| Имя переменной | Тип данных | Описание                        |
|----------------|------------|---------------------------------|
| `height`       | int        | Высота дерева                   |
| `root`         | int        | Значение корневого узла         |
| `tree`         | dict       | Словарь для хранения дерева     |
| `level`        | list       | Очередь для обхода в ширину     |
| `value`        | int        | Текущее значение узла           |
| `level_height` | int        | Текущий уровень узла            |
| `left_leaf`    | int        | Значение левого потомка         |
| `right_leaf`   | int        | Значение правого потомка        |

#### Алгоритм решения

1. **Инициализация**: Проверка базового случая (высота ≤ 0)
2. **Создание очереди**: Добавление корневого узла с уровнем 1
3. **Обход в ширину (BFS)**:
   - Извлечение узла из очереди
   - Добавление узла в словарь дерева
   - Если не достигнута максимальная высота:
     - Вычисление потомков
     - Добавление потомков в структуру узла
     - Добавление потомков в очередь для дальнейшей обработки
   - Иначе: установка потомков как None
4. **Завершение**: Возврат построенного дерева

#### Код программы

```python
def gen_bin_tree(height=5, root=1):
    """
    Нерекурсивно строит бинарное дерево в виде словаря используя обход в ширину (BFS).
    
    Параметры:
    height (int): Высота дерева. Определяет количество уровней в дереве.
                 По умолчанию: 5
    root (int): Значение корневого узла дерева.
               По умолчанию: 1
    
    Возвращает:
    dict: Словарь, представляющий бинарное дерево, где:
          - ключ: значение узла
          - значение: словарь с ключами 'left' и 'right', содержащими 
            значения потомков или None для листьев
          Пустой словарь если height <= 0
    """
    
    # БАЗОВЫЙ СЛУЧАЙ
    # Если высота дерева меньше или равна 0, возвращаем пустое дерево
    if height <= 0:
        return {}
    
    # ИНИЦИАЛИЗАЦИЯ СТРУКТУР ДАННЫХ
    # Словарь для хранения структуры дерева
    tree = {}
    # Очередь для обхода узлов в ширину (BFS)
    # Каждый элемент - кортеж (значение_узла, уровень)
    level = []
    # Добавляем корневой узел с уровнем 1 в очередь
    level.append((root, 1))

    # ОСНОВНОЙ АЛГОРИТМ - ОБХОД В ШИРИНУ (BFS)
    # Обрабатываем узлы пока очередь не пуста
    while level:
        # ИЗВЛЕЧЕНИЕ УЗЛА ИЗ ОЧЕРЕДИ
        # FIFO (First In First Out) - первый вошедший первый выходит
        value, level_height = level.pop(0)

        # СОЗДАНИЕ ЗАПИСИ ДЛЯ ТЕКУЩЕГО УЗЛА
        # Добавляем узел в словарь дерева
        tree[value] = {}

        # ПРОВЕРКА ВЫСОТЫ И СОЗДАНИЕ ПОТОМКОВ
        # Если не достигли максимальной высоты дерева
        if level_height < height:
            # ВЫЧИСЛЕНИЕ ЗНАЧЕНИЙ ПОТОМКОВ
            # Левый потомок = текущее значение × 2
            left_leaf = value * 2
            # Правый потомок = текущее значение + 3
            right_leaf = value + 3

            # ДОБАВЛЕНИЕ ПОТОМКОВ В СТРУКТУРУ УЗЛА
            tree[value]['left'] = left_leaf
            tree[value]['right'] = right_leaf

            # ДОБАВЛЕНИЕ ПОТОМКОВ В ОЧЕРЕДЬ
            # Добавляем потомков с увеличенным уровнем для дальнейшей обработки
            level.append((left_leaf, level_height + 1))
            level.append((right_leaf, level_height + 1))
        else:
            # ДОСТИГНУТЫ ЛИСТЬЯ - ПОТОМКИ ОТСУТСТВУЮТ
            # Если достигли максимальной высоты - устанавливаем потомков как None
            tree[value]['left'] = None
            tree[value]['right'] = None
            
    # ВОЗВРАТ РЕЗУЛЬТАТА
    # Возвращаем построенное бинарное дерево
    return tree
```

#### Результат работы программы

Для параметров `height=3, root=1` программа возвращает:

```python
{
    1: {'left': 2, 'right': 4},
    2: {'left': 4, 'right': 5},
    4: {'left': 8, 'right': 7},
    4: {'left': None, 'right': None},
    5: {'left': None, 'right': None},
    8: {'left': None, 'right': None},
    7: {'left': None, 'right': None}
}
```

---

### Задача: Модульное тестирование нерекурсивного бинарного дерева

#### Постановка задачи

Написать модульные тесты с помощью `unittest` для проверки корректности работы нерекурсивной функции `gen_bin_tree`. Тесты должны проверять:
- Корректность построения дерева для различных высот
- Правильность вычисления значений узлов
- Структуру дерева и связи между узлами
- Обработку граничных случаев

#### Математическая модель

Проверка соответствия фактического результата работы функции ожидаемым значениям:

```
Фактический_результат = gen_bin_tree(h, r)
Ожидаемый_результат = T(h, r)
Условие_корректности: Фактический_результат ≡ Ожидаемый_результат
```

#### Список идентификаторов

| Имя переменной | Тип данных | Описание                        |
|----------------|------------|---------------------------------|
| `result`       | dict       | Результат работы функции        |
| `expected`     | dict       | Ожидаемая структура дерева      |

#### Код программы

```python
import unittest
from lab4 import gen_bin_tree

class TestGenBinTree(unittest.TestCase):
    
    def test_zero_height(self):
        """Тест для высоты 0 - должно вернуться пустое дерево"""
        result = gen_bin_tree(height=0)
        self.assertEqual(result, {})
    
    def test_negative_height(self):
        """Тест для отрицательной высоты - должно вернуться пустое дерево"""
        result = gen_bin_tree(height=-1)
        self.assertEqual(result, {})
    
    def test_height_one(self):
        """Тест для высоты 1 - только корневой узел с пустыми потомками"""
        result = gen_bin_tree(height=1, root=10)
        expected = {
            10: {'left': None, 'right': None}
        }
        self.assertEqual

---

### Информация о студенте:

*Аглиуллин Амир, 1 курс, ИВТ-1(2).*