# Отчет по задачам для получения автомата

## Задача 1: Проверка сбалансированности скобок в выражении

**Постановка задачи:**  
Написать программу для проверки корректности расстановки круглых, фигурных и квадратных скобок в заданной строке с использованием стека.

**Математическая модель:**  
- Используется стек для хранения открывающих скобок
- Алгоритм:
  1. Инициализировать пустой стек
  2. Для каждого символа в строке:
     - Если символ - открывающая скобка, поместить в стек
     - Если символ - закрывающая скобка:
       - Если стек пуст → ошибка
       - Если тип скобки не соответствует вершине стека → ошибка
       - Иначе извлечь из стека
  3. Если после обработки всех символов стек не пуст → ошибка
  4. Иначе скобки сбалансированы

**Таблица идентификаторов:**
| Идентификатор | Тип        | Назначение                          |
|---------------|------------|-------------------------------------|
| stack         | char[]     | Массив для реализации стека        |
| top           | int        | Индекс вершины стека               |
| str           | char[]     | Входная строка с выражением        |
| c             | char       | Текущий символ строки              |
| push()        | функция    | Добавление элемента в стек         |
| pop()         | функция    | Извлечение элемента из стека       |
| is_empty()    | функция    | Проверка стека на пустоту          |
| is_match()    | функция    | Проверка соответствия скобок       |

**Код программы:**
```c
#include <stdio.h>
#include <stdbool.h>

#define MAX_SIZE 100

char stack[MAX_SIZE];
int top = -1;

// Функция добавления элемента в стек
void push(char c) {
    if (top >= MAX_SIZE - 1) {
        printf("Stack overflow\n");
        return;
    }
    stack[++top] = c;
}

// Функция извлечения элемента из стека
char pop() {
    if (top < 0) {
        printf("Stack underflow\n");
        return '\0';
    }
    return stack[top--];
}

// Функция проверки стека на пустоту
bool is_empty() {
    return top == -1;
}

// Функция проверки соответствия скобок
bool is_match(char open, char close) {
    return (open == '(' && close == ')') ||
           (open == '{' && close == '}') ||
           (open == '[' && close == ']');
}

// Основная функция проверки баланса скобок
bool is_balanced(char *str) {
    for (int i = 0; str[i] != '\0'; i++) {
        char c = str[i];
        if (c == '(' || c == '{' || c == '[') {
            push(c);
        } else if (c == ')' || c == '}' || c == ']') {
            if (is_empty() || !is_match(pop(), c)) {
                return false;
            }
        }
    }
    return is_empty();
}

int main() {
    char str[MAX_SIZE];
    printf("Введите строку со скобками: ");
    fgets(str, MAX_SIZE, stdin);

    if (is_balanced(str)) {
        printf("YES\n");
    } else {
        printf("NO\n");
    }

    return 0;
}
```

**Результат работы программы:**
```
Введите строку со скобками: (a + [b * {c - d}])
YES

Введите строку со скобками: {a + (b - c} * [d + e)]
NO
```

---

## Задача 2: Вычисление выражения в постфиксной нотации

**Постановка задачи:**  
Написать программу для вычисления значения арифметического выражения, заданного в обратной польской записи.

**Математическая модель:**  
- Используется стек для хранения операндов
- Алгоритм:
  1. Инициализировать пустой стек
  2. Для каждого токена в выражении:
     - Если токен - число → поместить в стек
     - Если токен - оператор:
       - Извлечь два верхних операнда из стека
       - Применить оператор к операндам
       - Поместить результат обратно в стек
  3. После обработки всех токенов в стеке должен остаться один элемент - результат

**Таблица идентификаторов:**
| Идентификатор | Тип        | Назначение                          |
|---------------|------------|-------------------------------------|
| stack         | int[]      | Массив для реализации стека        |
| top           | int        | Индекс вершины стека               |
| expr          | char[]     | Входное выражение                  |
| token         | char*      | Текущий токен выражения            |
| a, b         | int        | Операнды для вычисления            |
| push()        | функция    | Добавление числа в стек            |
| pop()         | функция    | Извлечение числа из стека          |
| is_operator() | функция    | Проверка символа на оператор       |
| calculate()   | функция    | Вычисление операции                |

**Код программы:**
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define MAX_SIZE 100

int stack[MAX_SIZE];
int top = -1;

// Функция добавления числа в стек
void push(int num) {
    if (top >= MAX_SIZE - 1) {
        printf("Stack overflow\n");
        exit(1);
    }
    stack[++top] = num;
}

// Функция извлечения числа из стека
int pop() {
    if (top < 0) {
        printf("Stack underflow\n");
        exit(1);
    }
    return stack[top--];
}

// Функция проверки, является ли символ оператором
int is_operator(char c) {
    return c == '+' || c == '-' || c == '*' || c == '/';
}

// Функция вычисления операции
int calculate(int a, int b, char op) {
    switch (op) {
        case '+': return a + b;
        case '-': return a - b;
        case '*': return a * b;
        case '/': 
            if (b == 0) {
                printf("Division by zero\n");
                exit(1);
            }
            return a / b;
        default:
            printf("Invalid operator\n");
            exit(1);
    }
}

// Основная функция вычисления постфиксного выражения
int evaluate_postfix(char *expr) {
    char *token = strtok(expr, " ");
    while (token != NULL) {
        if (isdigit(token[0])) {
            push(atoi(token));
        } else if (is_operator(token[0])) {
            int b = pop();
            int a = pop();
            push(calculate(a, b, token[0]));
        } else {
            printf("Invalid token: %s\n", token);
            exit(1);
        }
        token = strtok(NULL, " ");
    }
    
    if (top != 0) {
        printf("Invalid expression\n");
        exit(1);
    }
    
    return pop();
}

int main() {
    char expr[MAX_SIZE];
    printf("Введите выражение в постфиксной нотации: ");
    fgets(expr, MAX_SIZE, stdin);
    expr[strcspn(expr, "\n")] = '\0';

    int result = evaluate_postfix(expr);
    printf("Результат: %d\n", result);

    return 0;
}
```

**Результат работы программы:**
```
Введите выражение в постфиксной нотации: 5 3 2 * +
Результат: 11

Введите выражение в постфиксной нотации: 10 6 9 3 / + 11 * -
Результат: -39
```

---

## Задача 3: Генерация треугольника Паскаля

**Постановка задачи:**  
Написать программу, которая выводит первые N строк треугольника Паскаля, используя динамическое выделение памяти.

**Математическая модель:**  
- Каждое число в треугольнике Паскаля равно сумме двух чисел, расположенных над ним
- Формула для элемента C(n, k) = C(n-1, k-1) + C(n-1, k)
- Первый и последний элементы каждой строки равны 1

**Таблица идентификаторов:**
| Идентификатор | Тип        | Назначение                          |
|---------------|------------|-------------------------------------|
| n             | int        | Количество строк треугольника      |
| triangle      | int**      | Двумерный массив для треугольника  |
| i, j         | int        | Индексы строк и столбцов           |
| print_pascal()| функция    | Вывод треугольника Паскаля         |
| free_pascal() | функция    | Освобождение памяти                |

**Код программы:**
```c
#include <stdio.h>
#include <stdlib.h>

// Функция выделения памяти под треугольник Паскаля
int** allocate_pascal(int n) {
    int **triangle = (int **)malloc(n * sizeof(int *));
    if (triangle == NULL) {
        printf("Memory allocation failed\n");
        exit(1);
    }
    
    for (int i = 0; i < n; i++) {
        triangle[i] = (int *)malloc((i + 1) * sizeof(int));
        if (triangle[i] == NULL) {
            printf("Memory allocation failed\n");
            exit(1);
        }
        
        triangle[i][0] = 1;  // Первый элемент строки
        triangle[i][i] = 1;  // Последний элемент строки
        
        for (int j = 1; j < i; j++) {
            triangle[i][j] = triangle[i-1][j-1] + triangle[i-1][j];
        }
    }
    
    return triangle;
}

// Функция вывода треугольника Паскаля
void print_pascal(int **triangle, int n) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j <= i; j++) {
            printf("%d ", triangle[i][j]);
        }
        printf("\n");
    }
}

// Функция освобождения памяти
void free_pascal(int **triangle, int n) {
    for (int i = 0; i < n; i++) {
        free(triangle[i]);
    }
    free(triangle);
}

int main() {
    int n;
    printf("Введите количество строк треугольника Паскаля: ");
    scanf("%d", &n);
    
    int **triangle = allocate_pascal(n);
    print_pascal(triangle, n);
    free_pascal(triangle, n);
    
    return 0;
}
```

**Результат работы программы:**
```
Введите количество строк треугольника Паскаля: 5
1 
1 1 
1 2 1 
1 3 3 1 
1 4 6 4 1 
```

---

## Задача 4: Арифметические операции с дробями

**Постановка задачи:**  
Разработать программу для выполнения основных операций с обыкновенными дробями с последующим сокращением результата.

**Математическая модель:**  
- Дробь представляется структурой с числителем и знаменателем
- Операции:
  - Сложение: (a/b) + (c/d) = (ad + bc)/bd
  - Вычитание: (a/b) - (c/d) = (ad - bc)/bd
  - Умножение: (a/b) * (c/d) = (ac)/(bd)
  - Деление: (a/b) / (c/d) = (ad)/(bc)
- Сокращение дроби с помощью НОД (алгоритм Евклида)

**Таблица идентификаторов:**
| Идентификатор | Тип        | Назначение                          |
|---------------|------------|-------------------------------------|
| Fraction      | структура  | Структура для хранения дроби       |
| a, b, c, d   | int        | Числители и знаменатели дробей     |
| op            | char       | Оператор (+,-,*,/)                 |
| gcd()         | функция    | Вычисление НОД                     |
| reduce()      | функция    | Сокращение дроби                   |
| add()         | функция    | Сложение дробей                    |
| subtract()    | функция    | Вычитание дробей                   |
| multiply()    | функция    | Умножение дробей                   |
| divide()      | функция    | Деление дробей                     |

**Код программы:**
```c
#include <stdio.h>
#include <stdlib.h>

// Структура для хранения дроби
typedef struct {
    int numerator;
    int denominator;
} Fraction;

// Функция вычисления НОД (алгоритм Евклида)
int gcd(int a, int b) {
    a = abs(a);
    b = abs(b);
    while (b != 0) {
        int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}

// Функция сокращения дроби
void reduce(Fraction *f) {
    int common_divisor = gcd(f->numerator, f->denominator);
    f->numerator /= common_divisor;
    f->denominator /= common_divisor;
    
    // Убедимся, что знаменатель положительный
    if (f->denominator < 0) {
        f->numerator *= -1;
        f->denominator *= -1;
    }
}

// Функция сложения дробей
Fraction add(Fraction f1, Fraction f2) {
    Fraction result;
    result.numerator = f1.numerator * f2.denominator + f2.numerator * f1.denominator;
    result.denominator = f1.denominator * f2.denominator;
    reduce(&result);
    return result;
}

// Функция вычитания дробей
Fraction subtract(Fraction f1, Fraction f2) {
    Fraction result;
    result.numerator = f1.numerator * f2.denominator - f2.numerator * f1.denominator;
    result.denominator = f1.denominator * f2.denominator;
    reduce(&result);
    return result;
}

// Функция умножения дробей
Fraction multiply(Fraction f1, Fraction f2) {
    Fraction result;
    result.numerator = f1.numerator * f2.numerator;
    result.denominator = f1.denominator * f2.denominator;
    reduce(&result);
    return result;
}

// Функция деления дробей
Fraction divide(Fraction f1, Fraction f2) {
    if (f2.numerator == 0) {
        printf("Division by zero\n");
        exit(1);
    }
    Fraction result;
    result.numerator = f1.numerator * f2.denominator;
    result.denominator = f1.denominator * f2.numerator;
    reduce(&result);
    return result;
}

// Функция вывода дроби
void print_fraction(Fraction f) {
    printf("%d/%d\n", f.numerator, f.denominator);
}

int main() {
    int a, b, c, d;
    char op;
    
    printf("Введите выражение в формате A/B op C/D: ");
    if (scanf("%d/%d %c %d/%d", &a, &b, &op, &c, &d) != 5) {
        printf("Invalid input format\n");
        return 1;
    }
    
    if (b == 0 || d == 0) {
        printf("Denominator cannot be zero\n");
        return 1;
    }
    
    Fraction f1 = {a, b};
    Fraction f2 = {c, d};
    Fraction result;
    
    switch (op) {
        case '+':
            result = add(f1, f2);
            break;
        case '-':
            result = subtract(f1, f2);
            break;
        case '*':
            result = multiply(f1, f2);
            break;
        case '/':
            result = divide(f1, f2);
            break;
        default:
            printf("Invalid operator\n");
            return 1;
    }
    
    printf("Результат: ");
    print_fraction(result);
    
    return 0;
}
```

**Результат работы программы:**
```
Введите выражение в формате A/B op C/D: 1/2 + 3/4
Результат: 5/4

Введите выражение в формате A/B op C/D: 2/3 * 6/8
Результат: 1/2

Введите выражение в формате A/B op C/D: 3/4 / 0/1
Denominator cannot be zero
```

---

### Информация о студенте:
**Аглиуллин Амир, 1 курс, ИВТ-1(2).**
